import gradio as gr
import shutil
import uuid
import datetime
import json
from pathlib import Path
import os
import socket
import re
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
import mimetypes

#======================
#CONFIGURATION (FIXED)
#======================
MYLOCALIP = socket.gethostbyname(socket.gethostname()) if not socket.gethostname().startswith("localhost") else "127.0.0.1"
CMLOGS_DB_FNAME = "cmlogs-db.json"
SECRETFILE = "secret.json"
INST_RECIPIENTS_FILE = "CMemails.txt"          # Original INST team recipients
ICSS_RECIPIENTS_FILE = "CM-ICSS-emails.txt"    # NEW: ICSS team recipients
SENDER_EMAIL = "fabio.matricardi@gmail.com"
ATTACHMENTS_DIR = "attachments"
os.makedirs(ATTACHMENTS_DIR, exist_ok=True)

# Load Gmail password securely
GMAIL_APP_PASSWORD = None
try:
    with open(SECRETFILE) as f:
        GMAIL_APP_PASSWORD = json.load(f)['secret_code']
except Exception as e:
    print(f"‚ö†Ô∏è Secret file error: {e}. Email functionality disabled.")

# Initialize database if missing
if not os.path.exists(CMLOGS_DB_FNAME):
    with open(CMLOGS_DB_FNAME, 'w') as f:
        json.dump([], f)
    print(f"‚úÖ Created new log database: {CMLOGS_DB_FNAME}")

#======================
#CORE FUNCTIONS (FIXED)
#======================
def generate_next_id():
    """Safely generate next sequential ID from database"""
    try:
        with open(CMLOGS_DB_FNAME, 'r') as f:
            db = json.load(f)
        return max((entry.get('ID_db', 0) for entry in db), default=0) + 1
    except Exception as e:
        print(f"‚ö†Ô∏è ID generation error: {e}. Using timestamp-based ID.")
        return int(datetime.datetime.now().strftime("%Y%m%d%H%M%S"))

def load_recipients(filename):
    """Load valid emails from specified file (skip comments/empty lines)"""
    recipients = []
    try:
        with open(filename, 'r') as f:
            for line in f:
                email = line.strip()
                if email and not email.startswith('#') and '@' in email:
                    recipients.append(email)
        return recipients
    except FileNotFoundError:
        raise FileNotFoundError(f"Recipient file '{filename}' not found. Create it with one email per line.")
    except Exception as e:
        raise Exception(f"Error reading recipients from '{filename}': {str(e)}")

def save_to_database(entry):
    """Append new entry to JSON database"""
    try:
        with open(CMLOGS_DB_FNAME, 'r') as f:
            db = json.load(f)
    except:
        db = []
    db.append(entry)
    with open(CMLOGS_DB_FNAME, 'w') as f:
        json.dump(db, f, indent=2)

def send_email_with_exports(recipients, attachments_info, custom_note=""):
    """
    Send email with attachments and custom report note
    attachments_info: list of tuples (saved_filepath, original_filename)
    """
    if not GMAIL_APP_PASSWORD:
        return "‚ùå EMAIL NOT CONFIGURED: Missing valid GMAIL_APP_PASSWORD in secret.json"
    
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    # Extract ID safely for subject line
    try:
        report_id = custom_note.split('ID: ')[1].split('\n')[0].strip()
        subject = f"üîß Corrective Maintenance Notice #{report_id} - {timestamp}"
    except:
        subject = f"üîß Corrective Maintenance Notice - {timestamp}"

    # Build professional email body
    body = f"""CORRECTIVE MAINTENANCE ACTION REQUIRED
========================================
{custom_note}
‚ö†Ô∏è CONFIDENTIAL: Contains operational safety data.
Do not forward outside authorized Congo FLNG personnel.

System Details:
‚Ä¢ Generated by: NGUYA CM LOG SYSTEM
‚Ä¢ Timestamp: {timestamp} (Congo FLNG Time)
‚Ä¢ System IP: {MYLOCALIP}
‚Ä¢ Attachments: {len(attachments_info)} file(s)

Automated message from CM LOG SYSTEM
"""
    # Create MIME message
    message = MIMEMultipart()
    message['Subject'] = subject
    message['From'] = SENDER_EMAIL
    
    # Smart recipient display (first 3 + count)
    display_recipients = ', '.join(recipients[:3])
    if len(recipients) > 3:
        display_recipients += f" +{len(recipients)-3} others"
    message['To'] = display_recipients
    message.attach(MIMEText(body, 'plain'))

    # Attach files with original names preserved
    attached_names = []
    for filepath, orig_name in attachments_info:
        if not os.path.exists(filepath):
            print(f"‚ö†Ô∏è Skipping missing file: {filepath}")
            continue
            
        try:
            ctype, _ = mimetypes.guess_type(filepath)
            if ctype is None:
                ctype = 'application/octet-stream'
            maintype, subtype = ctype.split('/', 1)
            
            with open(filepath, 'rb') as fp:
                part = MIMEBase(maintype, subtype)
                part.set_payload(fp.read())
            encoders.encode_base64(part)
            part.add_header(
                'Content-Disposition',
                f'attachment; filename="{orig_name}"'
            )
            message.attach(part)
            attached_names.append(orig_name)
        except Exception as e:
            print(f"‚ö†Ô∏è Attachment error ({orig_name}): {str(e)}")

    # Send email
    try:
        with smtplib.SMTP_SSL('smtp.gmail.com', 465, timeout=30) as server:
            server.login(SENDER_EMAIL, GMAIL_APP_PASSWORD)
            server.send_message(message, to_addrs=recipients)
        return f"‚úÖ Email sent to {len(recipients)} recipient(s)! Attached: {', '.join(attached_names) if attached_names else 'None'}"
    except smtplib.SMTPAuthenticationError:
        return "‚ùå EMAIL AUTH FAILED: Invalid GMAIL_APP_PASSWORD. Contact administrator."
    except Exception as e:
        return f"‚ùå Email failed: {str(e)[:150]}"

def _submit_form_core(uploaded_files, tagname, description, reported_by, recipient_file):
    """Unified handler: validate ‚Üí save ‚Üí email (recipient_file specifies target list)"""
    # ===== VALIDATION =====
    errors = []
    if not tagname or not tagname.strip():
        errors.append("‚Ä¢ TAGNAME is mandatory")
    if not reported_by or not reported_by.strip():
        errors.append("‚Ä¢ 'Reported by' is mandatory")
    if uploaded_files and len(uploaded_files) > 10:
        errors.append("‚Ä¢ Maximum 10 files allowed")
    if errors:
        return "‚ùå **CORRECTION REQUIRED:**\n" + "\n".join(errors)

    # ===== PROCESS FILES =====
    attachments_info = []  # (saved_path, original_name)
    if uploaded_files:
        for temp_path in uploaded_files:
            orig_name = os.path.basename(temp_path)
            # Sanitize filename: remove dangerous chars
            safe_name = re.sub(r'[^\w\-_\.]', '_', orig_name)
            # Unique storage name: {UUID}_{original}
            storage_name = f"{uuid.uuid4().hex}_{safe_name}"
            dest_path = os.path.join(ATTACHMENTS_DIR, storage_name)
            
            try:
                shutil.copy(temp_path, dest_path)
                attachments_info.append((dest_path, orig_name))
            except Exception as e:
                return f"‚ùå File save error ({orig_name}): {str(e)}"

    # ===== GENERATE ID & SAVE TO DB =====
    next_id = generate_next_id()
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Build database entry
    db_entry = {
        "ID_db": next_id,
        "TAGNAME": tagname.strip(),
        "DESCRIPTION": description.strip() if description else "",
        "reported_by": reported_by.strip(),
        "timestamp": timestamp,
        "attachment_count": len(attachments_info),
        "original_filenames": [orig for _, orig in attachments_info]
    }

    try:
        save_to_database(db_entry)
    except Exception as e:
        return f"‚ùå Database save failed: {str(e)}"

    # ===== GENERATE EMAIL NOTE =====
    custom_note = f"""ID: CM-{next_id:05d}
TAGNAME: {tagname.strip()}
DESCRIPTION: {description.strip() if description else 'None provided'}
Reported by: {reported_by.strip()}
Timestamp: {timestamp}
Attachments: {len(attachments_info)} file(s)"""
    if attachments_info:
        custom_note += "\n\nAttached Files:\n" + "\n".join(f"‚Ä¢ {orig}" for _, orig in attachments_info)

    # ===== SEND EMAIL =====
    try:
        recipients = load_recipients(recipient_file)
        if not recipients:
            return f"‚ö†Ô∏è Report saved (ID: **CM-{next_id:05d}**), but NO RECIPIENTS FOUND in {recipient_file}. Email not sent."
    except Exception as e:
        return f"‚ö†Ô∏è Report saved (ID: **CM-{next_id:05d}**), recipient file error ({recipient_file}): {str(e)}"

    email_result = send_email_with_exports(recipients, attachments_info, custom_note)

    # ===== SUCCESS MESSAGE =====
    if email_result.startswith("‚úÖ"):
        return f"""‚úÖ **SUCCESS!**  
Report saved with ID: **CM-{next_id:05d}**  
{email_result}  
üìÅ Files archived in `{ATTACHMENTS_DIR}`"""
    else:
        return f"""‚ö†Ô∏è **PARTIAL SUCCESS**  
Report saved with ID: **CM-{next_id:05d}**  
üìß Email status: {email_result} (Data safely stored locally)"""

def submit_to_inst(uploaded_files, tagname, description, reported_by):
    msg = _submit_form_core(uploaded_files, tagname, description, reported_by, INST_RECIPIENTS_FILE)
    return msg, load_logs_for_display()  # RETURN TABLE DATA

def submit_to_icss(uploaded_files, tagname, description, reported_by):
    msg = _submit_form_core(uploaded_files, tagname, description, reported_by, ICSS_RECIPIENTS_FILE)
    return msg, load_logs_for_display()  # RETURN TABLE DATA


# TO LOAD THE EXISTING TICKETS
def load_logs_for_display():
    """Load last 20 log entries for display (most recent first)"""
    try:
        with open(CMLOGS_DB_FNAME, 'r') as f:
            db = json.load(f)
        # Sort descending + truncate description
        entries = sorted(db, key=lambda x: x.get('ID_db', 0), reverse=True)[:20]
        return [
            [
                f"CM-{e['ID_db']:05d}",
                e.get('TAGNAME', ''),
                (e.get('DESCRIPTION', '')[:47] + '...') if len(e.get('DESCRIPTION', '')) > 50 else e.get('DESCRIPTION', ''),
                e.get('reported_by', ''),
                e.get('timestamp', ''),
                e.get('attachment_count', 0)
            ]
            for e in entries
        ]
    except Exception as e:
        print(f"‚ö†Ô∏è Table load error: {e}")
        return []


#======================
#GRADIO INTERFACE (FIXED)
#======================
CUSTOM_CSS = """
#success-banner {
    background-color: #ecfdf5;
    border-left: 4px solid #10b981;
    padding: 15px;
    border-radius: 0 8px 8px 0;
    margin: 20px 0;
    font-weight: 500;
}
.footer-note {
    background-color: #f0f9ff;
    padding: 12px;
    border-radius: 6px;
    margin-top: 15px;
    font-size: 0.92em;
    border-left: 3px solid #3b82f6;
}
.gradio-container { max-width: 950px !important; margin: 0 auto !important; }
.compact-text { font-size: 0.95em; color: #555; margin-top: -8px; }
.required::after {
    content: " *";
    color: #ef4444;
    font-weight: bold;
}
.inst-btn {
    background: linear-gradient(to right, #10b981, #0da271) !important;
    color: white !important;
}
.icss-btn {
    background: linear-gradient(to right, #3b82f6, #2563eb) !important;
    color: white !important;
}
"""

with gr.Blocks(
    title="Corrective Maintenance Log",
    theme=gr.themes.Soft(primary_hue="emerald", secondary_hue="blue"),
    css=CUSTOM_CSS
) as demo:
    gr.Markdown(f"""# üîß Corrective Maintenance Log System
Submit equipment issues with supporting documentation.  
üåê Network Access: http://{MYLOCALIP}:7960""")
    gr.Markdown("""‚ö†Ô∏è **Mobile Users:** Tap the upload area ‚Üí Select "Camera" to capture photos directly  
(Works on Android/iOS - no app install needed)""", elem_classes=["footer-note"])
    
    with gr.Row():
        with gr.Column():
            file_upload = gr.File(
                label="üìé Attach Documentation (Photos, PDFs, etc.)",
                file_types=[".pdf", ".png", ".jpg", ".jpeg", ".bmp", ".webp"],
                file_count="multiple",
                type="filepath",
            )
            gr.Markdown("Max 10 files. Mobile: Select 'Camera' to capture new photos")
        
        with gr.Column():
            tagname = gr.Textbox(
                label="TAGNAME",
                info="Equipment tag or location identifier",
                placeholder="e.g., PUMP-205, VALVE-B3",
                elem_classes=["required"]
            )
            description = gr.Textbox(
                label="DESCRIPTION",
                info="Detailed issue description",
                placeholder="Describe the problem, symptoms, safety concerns...",
                lines=3,
                max_lines=6
            )
            reported_by = gr.Textbox(
                label="REPORTED BY",
                info="Your full name and role",
                placeholder="e.g., John Doe, Maintenance Technician",
                elem_classes=["required"]
            )
    
    # TWO BUTTONS FOR DEPARTMENTAL ROUTING
    with gr.Row():
        save_btn_inst = gr.Button(
            "üß∞ SAVE & SEND to INST", 
            variant="primary", 
            size="lg",
            elem_classes=["inst-btn"]
        )
        save_btn_icss = gr.Button(
            "üéõÔ∏è SAVE & SEND to ICSS", 
            variant="secondary", 
            size="lg",
            elem_classes=["icss-btn"]
        )
    
    output_msg = gr.Markdown("""\n\n Save and send operations displayed here.

Check status after submitting...


        """,elem_id="success-banner")
    
    accordionTEXT = f"""üìÅ Storage: Attachments saved to `{ATTACHMENTS_DIR}` | Database: `{CMLOGS_DB_FNAME}`<br>
üîí Security: All data remains on your local network. Emails require configured Gmail App Password.<br>
üí° Tip: ID format = CM-XXXXX (auto-generated after submission)<br>
üì§ Routing: INST button uses `{INST_RECIPIENTS_FILE}` | ICSS button uses `{ICSS_RECIPIENTS_FILE}`
"""
    
    # ===== LOG HISTORY TABLE =====
    gr.Markdown("## üìã Recent Maintenance Logs (Last 20 Entries)")
    log_table = gr.DataFrame(
        value=load_logs_for_display(),
        headers=["ID", "Tagname", "Description", "Reported By", "Timestamp", "Attachments"],
        datatype=["str", "str", "str", "str", "str", "number"],
        wrap=True,
        interactive=False,
        elem_classes=["log-table"]
    )

    gr.Markdown("---")
    with gr.Accordion("üìö Read Brief Manual",open=False):
        gr.Markdown(accordionTEXT, elem_classes=["footer-note"])    
    gr.Markdown("")

    # FOOTER
    with gr.Row():
        with gr.Column(scale=1):
            gr.Image("logo.png", height=40, container=False, buttons=[])
        with gr.Column(scale=2):
            gr.Markdown("**All rights reserved (C)**\n"
                       "created by fabio.matricardi@key-solution.eu for NGUYA FLNG Project\n"
                       f"visit [Key Solution SRL](https://key-solution.eu) | Network IP: {MYLOCALIP}")

    # Connect buttons WITH TABLE REFRESH
    save_btn_inst.click(
        fn=submit_to_inst,
        inputs=[file_upload, tagname, description, reported_by],
        outputs=[output_msg, log_table],  # TWO OUTPUTS NOW
        show_progress="full"
    )
    save_btn_icss.click(
        fn=submit_to_icss,
        inputs=[file_upload, tagname, description, reported_by],
        outputs=[output_msg, log_table],  # TWO OUTPUTS NOW
        show_progress="full"
    )

#======================
#LAUNCH (FIXED)
#======================
if __name__ == "__main__":
    print("\n" + "= "*70)
    print("üöÄ CORRECTIVE MAINTENANCE LOG SYSTEM - READY")
    print("= "*70)
    print(f"‚úÖ Attachments directory: {os.path.abspath(ATTACHMENTS_DIR)}")
    print(f"‚úÖ Database file: {os.path.abspath(CMLOGS_DB_FNAME)}")
    print(f"‚úÖ INST Recipients file: {os.path.abspath(INST_RECIPIENTS_FILE)} (must contain emails)")
    print(f"‚úÖ ICSS Recipients file: {os.path.abspath(ICSS_RECIPIENTS_FILE)} (must contain emails)")
    print(f"\nüåê ACCESS VIA:")
    print(f"   ‚Ä¢ Local: http://localhost:7960")
    print(f"   ‚Ä¢ Network: http://{MYLOCALIP}:7960")
    print("\n‚ö†Ô∏è EMAIL REQUIREMENTS:")
    print("   ‚Ä¢ secret.json must contain valid Gmail App Password")
    print("   ‚Ä¢ Both recipient files must exist with emails (one per line, comments with # allowed)")
    print("= "*70 + "\n")
    
    demo.launch()